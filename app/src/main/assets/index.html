<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aviation Weather Report (TAF & METAR)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- We keep jsPDF for the PDF option -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>

    <!-- Flatpickr for enforced 24h UTC inputs -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .font-mono { font-family: 'JetBrains Mono', 'Courier New', monospace; }

        /* Custom styles for the colored legend dots */
        .weather-dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 4px;
            flex-shrink: 0;
        }

        /* Weather Colors */
        .vfr-dot { background-color: rgb(0, 170, 0); } /* Green */
        .mvfr-dot { background-color: rgb(0, 50, 160); } /* Blue */
        .ifr-dot { background-color: rgb(200, 0, 0); } /* Red */
        .lifr-dot { background-color: rgb(255, 20, 147); } /* Magenta */

        /* Advanced Tab Tiles */
        .vfr-tile { background-color: rgb(0, 170, 0); }
        .mvfr-tile { background-color: rgb(0, 50, 160); }
        .ifr-tile { background-color: rgb(200, 0, 0); }
        .lifr-tile { background-color: rgb(255, 20, 147); }
        .nodata-tile { background-color: rgb(150, 150, 150); }

        /* Flatpickr Customization for consistent UI */
        .flatpickr-calendar {
            font-family: 'Inter', sans-serif;
        }

        /* Update Banner Animation */
        @keyframes slideDown {
            from { transform: translateY(-100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        .update-banner-enter {
            animation: slideDown 0.5s ease-out forwards;
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-100 min-h-full antialiased">

<!-- Update Notification Banner (Hidden by default) -->
<div id="updateBanner" class="hidden fixed top-0 left-0 right-0 z-50 p-4 bg-blue-600 text-white shadow-xl">
    <div class="container mx-auto max-w-5xl flex flex-col sm:flex-row items-center justify-between gap-4">
        <div class="flex items-center gap-3">
            <div class="bg-white/20 p-2 rounded-full">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                </svg>
            </div>
            <div>
                <p class="font-bold text-lg">New Version Available!</p>
                <p class="text-blue-100 text-sm">Version <span id="newVersionTag"></span> is ready to download.</p>
            </div>
        </div>
        <div class="flex items-center gap-3 w-full sm:w-auto">
            <a id="downloadUpdateBtn" href="#" class="flex-1 sm:flex-none text-center bg-white text-blue-600 hover:bg-blue-50 font-bold py-2 px-6 rounded-lg transition-colors shadow-sm">
                Download Update
            </a>
            <button id="closeUpdateBanner" class="p-2 hover:bg-blue-700 rounded-lg transition-colors" aria-label="Close">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
        </div>
    </div>
</div>

<div class="container mx-auto p-4 md:p-8 max-w-5xl pt-8 mt-4"> <!-- Added top padding/margin to account for banner if present -->
    <header class="mb-8 text-center">
        <h1 class="text-3xl font-bold text-blue-600 dark:text-blue-400">Aviation Weather Generator</h1>
        <p class="text-gray-600 dark:text-gray-400 mt-2">
            Generates a report of current METARs and TAFs, view in-app or download as PDF.
        </p>
        <div class="flex justify-center flex-wrap gap-x-4 mt-4 text-sm font-bold">
            <span class="flex items-center gap-1"><span class="weather-dot vfr-dot"></span>VFR</span>
            <span class="flex items-center gap-1"><span class="weather-dot mvfr-dot"></span>MVFR</span>
            <span class="flex items-center gap-1"><span class="weather-dot ifr-dot"></span>IFR</span>
            <span class="flex items-center gap-1"><span class="weather-dot lifr-dot"></span>LIFR</span>
            <span id="nodata-legend" class="flex items-center gap-1 text-gray-500" style="display: none;"><span class="weather-dot nodata-tile"></span>No TAF Data</span>
        </div>
    </header>

    <!-- Main Settings and Advanced Toggle -->
    <div class="bg-white dark:bg-gray-800 p-6 rounded-xl shadow-lg mb-6">
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            <!-- Output Mode Option -->
            <div>
                <label for="outputMode" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                    Output Mode
                </label>
                <select id="outputMode" class="w-full p-2.5 border border-gray-300 dark:border-gray-600 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-gray-200 focus:ring-blue-500 focus:border-blue-500 transition duration-150">
                    <option value="browser">View in App</option>
                    <option value="pdf">Download PDF</option>
                </select>
            </div>

            <!-- Home ICAO Input & Sorting Option -->
            <div class="md:col-span-1">
                <label for="sortMode" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                    Sort Results By
                </label>
                <select id="sortMode" class="w-full p-2.5 border border-gray-300 dark:border-gray-600 rounded-lg bg-gray-50 dark:bg-gray-700 dark:text-gray-200 focus:ring-blue-500 focus:border-blue-500 transition duration-150">
                    <option value="alpha">Alphabetical (ICAO)</option>
                    <option value="distance" disabled>Distance to Home Airport</option>
                </select>

                <div class="mt-3 p-3 bg-gray-50 dark:bg-gray-700/50 rounded-lg border border-gray-200 dark:border-gray-700">
                    <label for="icaoInput" class="block text-xs font-medium text-gray-500 dark:text-gray-400 mb-1">
                        Home Airport (Optional)
                    </label>
                    <input type="text" id="icaoInput" maxlength="4" placeholder="e.g. KOKC"
                           class="uppercase w-full p-2 text-sm border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-800 dark:text-gray-100 focus:ring-blue-500 focus:border-blue-500 tracking-widest font-mono transition-colors">
                    <p class="text-xs text-gray-400 mt-1">Enter 4 letter ICAO code to enable distance sorting.</p>
                </div>
            </div>

            <!-- Advanced Planning Toggle -->
            <div class="md:col-span-1 flex items-end">
                <div class="w-full">
                    <p class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Alternate Analysis</p>
                    <button id="toggleAdvanced"
                            class="w-full bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2.5 px-4 rounded-lg shadow-md transition duration-150 focus:outline-none focus:ring-2 focus:ring-yellow-500 focus:ring-offset-2 dark:focus:ring-offset-gray-900">
                        Enable Alternate Planner
                    </button>
                </div>
            </div>
        </div>

        <!-- Advanced Planning Inputs (Initially Hidden) -->
        <div id="advancedInputs" class="hidden mt-6 pt-4 border-t border-gray-200 dark:border-gray-700">
            <h3 class="text-lg font-semibold text-blue-600 dark:text-blue-400 mb-4">Flight Plan Details</h3>
            <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4">
                <!-- Departure -->
                <div>
                    <label for="depIcao" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                        Departure Airport (ICAO)
                    </label>
                    <input type="text" id="depIcao" maxlength="4" placeholder="e.g. KSEA"
                           class="uppercase w-full p-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 dark:text-gray-100 focus:ring-blue-500 focus:border-blue-500 font-mono transition-colors">
                </div>
                <!-- Destination -->
                <div>
                    <label for="destIcao" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                        Destination Airport (ICAO)
                    </label>
                    <input type="text" id="destIcao" maxlength="4" placeholder="e.g. KSAN"
                           class="uppercase w-full p-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 dark:text-gray-100 focus:ring-blue-500 focus:border-blue-500 font-mono transition-colors">
                </div>
                <!-- Takeoff Time -->
                <div>
                    <label for="takeOffTime" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                        Takeoff Time (UTC)
                    </label>
                    <!-- Type text for Flatpickr -->
                    <input type="text" id="takeOffTime" placeholder="YYYY-MM-DD HH:MM" required
                           class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 dark:text-gray-100 focus:ring-blue-500 focus:border-blue-500 transition-colors cursor-pointer">
                </div>
                <!-- Landing Time -->
                <div>
                    <label for="landingTime" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                        Landing Time (UTC)
                    </label>
                    <!-- Type text for Flatpickr -->
                    <input type="text" id="landingTime" placeholder="YYYY-MM-DD HH:MM" required
                           class="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 dark:text-gray-100 focus:ring-blue-500 focus:border-blue-500 transition-colors cursor-pointer">
                </div>
            </div>
        </div>

        <div class="mt-6 text-center">
            <button id="generateButton"
                    class="w-full md:w-auto bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-12 rounded-lg shadow-lg transform transition-transform hover:scale-[1.02] focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-gray-900">
                Generate Report
            </button>
        </div>
    </div>

    <div id="status" class="hidden mt-6 p-4 text-center rounded-lg"></div>
    <div id="details" class="hidden mt-2 text-sm text-gray-500 text-center font-mono"></div>

    <!-- Results Container -->
    <div id="resultsContainer" class="hidden mt-8 p-4 bg-white dark:bg-gray-800 rounded-xl shadow-inner max-h-[85vh] flex flex-col">

        <!-- Updated Elegant Navigation Tabs -->
        <div class="mb-4">
            <!-- Container now uses utility classes directly -->
            <div class="flex p-1 space-x-1 bg-gray-200 dark:bg-gray-700 rounded-xl">
                <button id="tabStandard"
                        class="tab-button w-full py-2.5 text-sm font-medium leading-5 rounded-lg text-center transition-all duration-200 focus:outline-none bg-white dark:bg-gray-600 text-blue-700 dark:text-blue-200 shadow">
                    Standard Report
                </button>
                <button id="tabRouteAnalysis"
                        class="tab-button w-full py-2.5 text-sm font-medium leading-5 rounded-lg text-center transition-all duration-200 focus:outline-none text-gray-700 dark:text-gray-200 hover:bg-gray-300 dark:hover:bg-gray-600 hidden">
                    Alternate Analysis
                </button>
            </div>
        </div>

        <!-- Tab Content -->
        <div class="flex-grow overflow-y-auto">
            <div id="weatherList" class="space-y-6 tab-content"></div>
            <div id="routeAnalysisView" class="hidden tab-content p-4"></div>
        </div>
    </div>
</div>

<script>
    // --- APP UPDATE CONFIGURATION ---
    // IMPORTANT: Update this constant when releasing a new version!
    const CURRENT_VERSION = 'v1.3.4';
    const GITHUB_REPO = 'Unpiloted0852/AvWx';

    // --- LIBRARIES ---
    const { jsPDF } = window.jspdf;
    const generateButton = document.getElementById('generateButton');
    const outputModeSelect = document.getElementById('outputMode');
    const sortModeSelect = document.getElementById('sortMode');
    const icaoInput = document.getElementById('icaoInput');
    const statusEl = document.getElementById('status');
    const detailsEl = document.getElementById('details');
    const resultsContainerEl = document.getElementById('resultsContainer');
    const weatherListEl = document.getElementById('weatherList');
    const routeAnalysisViewEl = document.getElementById('routeAnalysisView');
    const toggleAdvancedButton = document.getElementById('toggleAdvanced');
    const advancedInputsEl = document.getElementById('advancedInputs');
    const tabStandard = document.getElementById('tabStandard');
    const tabRouteAnalysis = document.getElementById('tabRouteAnalysis');
    const nodataLegendEl = document.getElementById('nodata-legend');

    // Advanced Inputs
    const depIcaoInput = document.getElementById('depIcao');
    const destIcaoInput = document.getElementById('destIcao');
    const takeOffTimeInput = document.getElementById('takeOffTime');
    const landingTimeInput = document.getElementById('landingTime');

    // URLs
    const TAF_DATA_URL = 'https://aviationweather.gov/data/cache/tafs.cache.xml.gz';
    const METAR_DATA_URL = 'https://aviationweather.gov/data/cache/metars.cache.xml.gz';
    const STATIONS_DATA_URL = 'https://aviationweather.gov/data/cache/stations.cache.xml.gz';
    const PROXY_URL = 'https://corsproxy.io/?';

    const MAX_RETRIES = 3;
    const PAGE_MARGIN = 15;
    const PAGE_WIDTH = 210;
    const PAGE_HEIGHT = 297;
    const USABLE_WIDTH = PAGE_WIDTH - (PAGE_MARGIN * 2);
    const LINE_SPACING = 4;
    const MAX_ROUTE_DISTANCE_NM = 220;

    // Cache
    let cachedStationMap = null;
    let routeAnalysisEnabled = false;

    const CATEGORY_ORDER = {
        'LIFR': 4,
        'IFR': 3,
        'MVFR': 2,
        'VFR': 1,
        'NODATA': 0 // Lowest priority
    };

    const COLORS = {
        VFR: [0, 170, 0],
        MVFR: [0, 50, 160],
        IFR: [200, 0, 0],
        LIFR: [255, 20, 147],
        NODATA: [150, 150, 150]
    };

    // --- INITIALIZATION ---
    function formatUtcForInput(date) {
        const Y = date.getUTCFullYear();
        const M = String(date.getUTCMonth() + 1).padStart(2, '0');
        const D = String(date.getUTCDate()).padStart(2, '0');
        const h = String(date.getUTCHours()).padStart(2, '0');
        const m = String(date.getUTCMinutes()).padStart(2, '0');
        return `${Y}-${M}-${D} ${h}:${m}`;
    }

    function parseUtcString(str) {
        if (!str) return null;
        return new Date(str.replace(' ', 'T') + 'Z');
    }

    function initializeTimeInputs() {
        const now = new Date();
        const takeoffDefault = new Date(now.getTime() + 60 * 60 * 1000);
        const landingDefault = new Date(now.getTime() + 3 * 60 * 60 * 1000);

        const commonConfig = {
            enableTime: true,
            dateFormat: "Y-m-d H:i",
            time_24hr: true,
            minuteIncrement: 1,
            static: true
        };

        flatpickr("#takeOffTime", {
            ...commonConfig,
            defaultDate: formatUtcForInput(takeoffDefault)
        });

        flatpickr("#landingTime", {
            ...commonConfig,
            defaultDate: formatUtcForInput(landingDefault)
        });
    }
    initializeTimeInputs();

    function formatTimeHHMM(date) {
        const h = String(date.getUTCHours()).padStart(2, '0');
        const m = String(date.getUTCMinutes()).padStart(2, '0');
        return `${h}:${m}Z`;
    }

    // --- EVENT LISTENERS ---
    generateButton.addEventListener('click', handleGenerateClick);
    toggleAdvancedButton.addEventListener('click', toggleAdvancedPanel);
    tabStandard.addEventListener('click', () => switchTab('standard'));
    tabRouteAnalysis.addEventListener('click', () => switchTab('route-analysis'));

    // --- PERSISTENCE & AUTO-FILL LOGIC ---
    let isMirroringHome = false;

    function loadSavedInputs() {
        const savedHome = localStorage.getItem('homeIcao');
        const savedDep = localStorage.getItem('depIcao');
        const savedDest = localStorage.getItem('destIcao');

        if (savedHome) {
            icaoInput.value = savedHome;
            updateSortOptions();
        }
        if (savedDep) depIcaoInput.value = savedDep;
        if (savedDest) destIcaoInput.value = savedDest;
    }

    icaoInput.addEventListener('input', () => {
        isMirroringHome = false;
        localStorage.setItem('homeIcao', icaoInput.value);
        updateSortOptions();
    });

    depIcaoInput.addEventListener('input', () => {
        const val = depIcaoInput.value;
        localStorage.setItem('depIcao', val);
        if (!icaoInput.value.trim()) isMirroringHome = true;
        if (isMirroringHome) {
            icaoInput.value = val;
            localStorage.setItem('homeIcao', val);
            updateSortOptions();
        }
    });

    destIcaoInput.addEventListener('input', () => {
         localStorage.setItem('destIcao', destIcaoInput.value);
    });

    loadSavedInputs();
    updateSortOptions();

    function updateSortOptions() {
        const hasICAO = icaoInput.value.trim().length >= 3;
        const distOption = sortModeSelect.querySelector('option[value="distance"]');

        if (hasICAO) {
            const wasDisabled = distOption.disabled;
            distOption.disabled = false;
            if (wasDisabled || sortModeSelect.value === 'alpha') {
                sortModeSelect.value = 'distance';
            }
        } else {
            distOption.disabled = true;
            if (sortModeSelect.value === 'distance') {
                sortModeSelect.value = 'alpha';
            }
        }
    }

    function toggleAdvancedPanel() {
        const isHidden = advancedInputsEl.classList.contains('hidden');
        if (isHidden) {
            advancedInputsEl.classList.remove('hidden');
            toggleAdvancedButton.textContent = 'Disable Alternate Planning';
            toggleAdvancedButton.classList.remove('bg-yellow-500', 'hover:bg-yellow-600');
            toggleAdvancedButton.classList.add('bg-gray-500', 'hover:bg-gray-600');
            routeAnalysisEnabled = true;
            nodataLegendEl.style.display = 'flex';
        } else {
            advancedInputsEl.classList.add('hidden');
            toggleAdvancedButton.textContent = 'Enable Alternate Planning';
            toggleAdvancedButton.classList.add('bg-yellow-500', 'hover:bg-yellow-600');
            toggleAdvancedButton.classList.remove('bg-gray-500', 'hover:bg-gray-600');
            routeAnalysisEnabled = false;
            tabRouteAnalysis.classList.add('hidden');
            nodataLegendEl.style.display = 'none';
        }
    }

    const TAB_ACTIVE_CLASSES = ['bg-white', 'dark:bg-gray-600', 'text-blue-700', 'dark:text-blue-200', 'shadow'];
    const TAB_INACTIVE_CLASSES = ['text-gray-700', 'dark:text-gray-200', 'hover:bg-gray-300', 'dark:hover:bg-gray-600'];

    function switchTab(tabId) {
        const contents = document.querySelectorAll('.tab-content');
        const buttons = document.querySelectorAll('.tab-button');
        contents.forEach(el => el.classList.add('hidden'));
        buttons.forEach(btn => {
            btn.classList.remove(...TAB_ACTIVE_CLASSES);
            btn.classList.add(...TAB_INACTIVE_CLASSES);
        });

        if (tabId === 'standard') {
            weatherListEl.classList.remove('hidden');
            tabStandard.classList.remove(...TAB_INACTIVE_CLASSES);
            tabStandard.classList.add(...TAB_ACTIVE_CLASSES);
        } else if (tabId === 'route-analysis') {
            routeAnalysisViewEl.classList.remove('hidden');
            tabRouteAnalysis.classList.remove(...TAB_INACTIVE_CLASSES);
            tabRouteAnalysis.classList.add(...TAB_ACTIVE_CLASSES);
        }
    }

    // --- UPDATE CHECKER LOGIC ---

    async function checkForUpdates() {
        try {
            const response = await fetch(`https://api.github.com/repos/${GITHUB_REPO}/releases/latest`);
            if (!response.ok) return;

            const data = await response.json();
            const latestVersion = data.tag_name;

            if (isNewerVersion(CURRENT_VERSION, latestVersion)) {
                showUpdateBanner(latestVersion, data);
            }
        } catch (error) {
            console.warn("Failed to check for updates:", error);
        }
    }

    function isNewerVersion(current, latest) {
        // Remove 'v' prefix if present
        const cleanCurrent = current.replace(/^v/, '');
        const cleanLatest = latest.replace(/^v/, '');

        const currentParts = cleanCurrent.split('.').map(Number);
        const latestParts = cleanLatest.split('.').map(Number);

        for (let i = 0; i < Math.max(currentParts.length, latestParts.length); i++) {
            const curr = currentParts[i] || 0;
            const lat = latestParts[i] || 0;
            if (lat > curr) return true;
            if (lat < curr) return false;
        }
        return false;
    }

    function showUpdateBanner(version, releaseData) {
        const banner = document.getElementById('updateBanner');
        const versionSpan = document.getElementById('newVersionTag');
        const downloadBtn = document.getElementById('downloadUpdateBtn');
        const closeBtn = document.getElementById('closeUpdateBanner');

        versionSpan.textContent = version;

        // Try to find the APK asset
        const apkAsset = releaseData.assets && releaseData.assets.find(asset => asset.name.toLowerCase().endsWith('.apk'));
        let downloadUrl = releaseData.html_url;

        if (apkAsset) {
            downloadUrl = apkAsset.browser_download_url;
        }

        // --- NEW LOGIC: Intercept Click with Robust Fallback ---
        downloadBtn.onclick = (e) => {

            // 1. Try Android Interface (Specific 'launchUpdate' method)
            if (window.Android && typeof window.Android.launchUpdate === 'function') {
                e.preventDefault();
                console.log("Calling Android.launchUpdate with: " + downloadUrl);
                window.Android.launchUpdate(downloadUrl);
            }
            // 2. Warn if Android interface exists but is outdated
            else if (window.Android) {
                console.warn("window.Android exists but launchUpdate is missing. Update your Android Java code!");
                // We let the default link click happen as a fallback,
                // but usually WebViews ignore this without extra Java handling.
            }
            // 3. Browser fallback (default <a> tag behavior)
            else {
                console.log("Standard browser navigation");
            }
        };

        // Ensure href is set for fallback
        downloadBtn.href = downloadUrl;

        banner.classList.remove('hidden');
        banner.classList.add('update-banner-enter');

        closeBtn.onclick = () => {
            banner.classList.add('hidden');
        };
    }

    // Call update checker on load
    checkForUpdates();


    // --- UTILS ---

    function showStatus(message, isError = false, details = "") {
        resultsContainerEl.classList.add('hidden');
        statusEl.textContent = message;
        statusEl.className = 'mt-6 p-4 text-center rounded-lg';

        if (isError) {
            statusEl.classList.add('bg-red-100', 'dark:bg-red-900', 'text-red-700', 'dark:text-red-200');
        } else {
            statusEl.classList.add('bg-blue-100', 'dark:bg-blue-900', 'text-blue-700', 'dark:text-blue-200');
        }
        statusEl.style.display = 'block';

        detailsEl.textContent = details || '';
        detailsEl.style.display = details ? 'block' : 'none';
    }

    function showSuccess(message) {
        statusEl.textContent = message;
        statusEl.className = 'mt-6 p-4 text-center rounded-lg bg-green-100 dark:bg-green-900 text-green-700 dark:text-green-200';
        statusEl.style.display = 'block';
        detailsEl.style.display = 'none';
    }

    function haversineDistance(lat1, lon1, lat2, lon2) {
        const R = 6371;
        const toRad = (deg) => deg * (Math.PI / 180);
        const dLat = toRad(lat2 - lat1);
        const dLon = toRad(lon2 - lon1);
        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                  Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
                  Math.sin(dLon / 2) * Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return (R * c) * 0.539957; // Convert km to NM
    }

    function calculateAgeInMinutes(isoTimestamp) {
        try {
            const timestamp = new Date(isoTimestamp);
            const now = new Date();
            const diffMs = now.getTime() - timestamp.getTime();
            return Math.floor(diffMs / (1000 * 60));
        } catch (e) {
            return null;
        }
    }

    function formatAge(minutes) {
        if (minutes === null || isNaN(minutes)) return "N/A";
        if (minutes < 60) return `${minutes} min ago`;
        if (minutes < 1440) {
            const hours = Math.floor(minutes / 60);
            const remainingMinutes = minutes % 60;
            return remainingMinutes > 0 ? `${hours}h ${remainingMinutes}m ago` : `${hours} hours ago`;
        }
        const days = Math.floor(minutes / 1440);
        return `${days} days ago`;
    }

    function getCategoryColor(cat) {
        if (!cat) return COLORS.VFR;
        const c = cat.toUpperCase().trim();
        return COLORS[c] || COLORS.VFR;
    }

    function getCategoryClassName(cat) {
        if (!cat) return 'vfr-dot';
        const c = cat.toUpperCase().trim();
        const map = {
            'LIFR': 'lifr-dot',
            'IFR': 'ifr-dot',
            'MVFR': 'mvfr-dot',
            'NODATA': 'nodata-tile'
        };
        return map[c] || 'vfr-dot';
    }

    function getCategoryTileClassName(cat) {
        if (!cat) return 'vfr-tile';
        const c = cat.toUpperCase().trim();
        const map = {
            'LIFR': 'lifr-tile',
            'IFR': 'ifr-tile',
            'MVFR': 'mvfr-tile',
            'NODATA': 'nodata-tile'
        };
        return map[c] || 'vfr-tile';
    }

    function getCategoryPriority(cat) {
        if (!cat) return CATEGORY_ORDER.VFR;
        const c = cat.toUpperCase().trim();
        return CATEGORY_ORDER[c] || CATEGORY_ORDER.VFR;
    }

    // --- PARSING ---

    function calculateTempFAndRH(metarNode) {
        const tempC = parseFloat(metarNode.querySelector("temp_c")?.textContent);
        const dewpointC = parseFloat(metarNode.querySelector("dewpoint_c")?.textContent);
        if (isNaN(tempC) || isNaN(dewpointC)) return { tempF: "N/A", rh: "N/A" };
        const tempF = Math.round(tempC * 9/5 + 32);
        const satVP = 6.112 * Math.exp((17.67 * tempC) / (tempC + 243.5));
        const actVP = 6.112 * Math.exp((17.67 * dewpointC) / (dewpointC + 243.5));
        const rh = Math.round(actVP / satVP * 100);
        return { tempF: `${tempF}°F`, rh: `RH ${rh}%` };
    }

   function analyzeCondition(text) {
        const suf = '(?:TCU|CB)?';
        const isLIFR_Ceil = new RegExp(`(BKN|OVC|VV)00[0-4]${suf}\\b`).test(text);
        const isIFR_Ceil = new RegExp(`(BKN|OVC|VV)00[5-9]${suf}\\b`).test(text);
        const isMVFR_Ceil = new RegExp(`(BKN|OVC|VV)(0[1-2]\\d|030)${suf}\\b`).test(text);
        const isLIFR_SM = /\b(M)?(0|1)\/\dSM\b|\b0SM\b|\b(M)?0SM\b|\b(M)?1\/[248]SM\b/.test(text);
        const isLIFR_M = /(?:^|\s)(0\d{3}|1[0-5]\d{2})(?=\s|$)/.test(text);
        const isIFR_SM = /\b[1-2]( \d\/\d)?SM\b|\b1SM\b|\b2SM\b/.test(text);
        const isIFR_M = /(?:^|\s)(1[6-9]\d{2}|[2-4]\d{3})(?=\s|$)/.test(text);
        const isMVFR_SM = /\b[3-5]SM\b/.test(text);
        const isMVFR_M = /(?:^|\s)([5-7]\d{3}|8000)(?=\s|$)/.test(text);

        if (isLIFR_Ceil || isLIFR_SM || isLIFR_M) return 'LIFR';
        if (isIFR_Ceil || isIFR_SM || isIFR_M) return 'IFR';
        if (isMVFR_Ceil || isMVFR_SM || isMVFR_M) return 'MVFR';
        return 'VFR';
    }

    function fetchWithRetry(fn, retries = MAX_RETRIES) {
        return new Promise((resolve, reject) => {
            const attempt = (n) => {
                fn().then(resolve).catch(err => {
                    if (n === 0) return reject(err);
                    setTimeout(() => attempt(n - 1), Math.pow(2, MAX_RETRIES - n) * 1000);
                });
            };
            attempt(retries);
        });
    }

    async function fetchAndParse(url) {
        const fetchUrl = PROXY_URL + encodeURIComponent(url);
        return fetchWithRetry(async () => {
            const response = await fetch(fetchUrl);
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            const buffer = await response.arrayBuffer();
            if (buffer.byteLength === 0) throw new Error("Empty file");
            const decompressed = pako.inflate(new Uint8Array(buffer));
            const xmlText = new TextDecoder("utf-8").decode(decompressed);
            if (!xmlText.trim()) throw new Error("Decompressed empty");
            const xmlDoc = new DOMParser().parseFromString(xmlText, "application/xml");
            if (xmlDoc.querySelector("parsererror")) throw new Error("XML parse error");
            return xmlDoc;
        });
    }

    async function getStationMap() {
        if (cachedStationMap) return cachedStationMap;
        try {
            const stationsDoc = await fetchAndParse(STATIONS_DATA_URL);
            const map = new Map();
            stationsDoc.querySelectorAll("Station").forEach(node => {
                const id = node.querySelector("station_id")?.textContent;
                const site = node.querySelector("site")?.textContent;
                const state = node.querySelector("state")?.textContent;
                const country = node.querySelector("country")?.textContent;
                const lat = parseFloat(node.querySelector("latitude")?.textContent);
                const lon = parseFloat(node.querySelector("longitude")?.textContent);
                if (id && site) {
                    const cleanSite = site.trim().replace(/\/INTL$/, '').replace(/\//g, ' ');
                    let label = cleanSite;
                    if (country === 'US' && state) label += `, ${state}`;
                    else if (country) label += `, ${country}`;
                    else if (state) label += `, ${state}`;
                    map.set(id, {
                        name: label,
                        latitude: isNaN(lat) ? null : lat,
                        longitude: isNaN(lon) ? null : lon
                    });
                }
            });
            cachedStationMap = map;
            return map;
        } catch (e) {
            console.warn("Failed to fetch station DB, proceeding without names/coords", e);
            return new Map();
        }
    }

    function getCoordsForICAO(icao, stationMap) {
        const data = stationMap.get(icao.toUpperCase());
        return data ? { lat: data.latitude, lon: data.longitude } : null;
    }

    function resolveTafDate(issueDate, day, hour) {
        const date = new Date(issueDate);
        date.setUTCDate(day);
        date.setUTCHours(hour);
        date.setUTCMinutes(0);
        date.setUTCSeconds(0);
        if (day < issueDate.getUTCDate() - 5) date.setUTCMonth(date.getUTCMonth() + 1);
        else if (day > issueDate.getUTCDate() + 5) date.setUTCMonth(date.getUTCMonth() - 1);
        return date;
    }

    function getWorstFlightCategoryFromTAF(tafRawText, forecastStart, forecastEnd) {
        if (!tafRawText) return 'NODATA';
        const tafValidMatch = tafRawText.match(/(\d{6})Z/);
        const now = new Date();
        let issueTime = new Date(now);
        if (tafValidMatch) {
            const day = parseInt(tafValidMatch[1].substring(0, 2));
            const hour = parseInt(tafValidMatch[1].substring(2, 4));
            issueTime = resolveTafDate(now, day, hour);
        }

        const tokens = tafRawText.split(/\s(?=(FM\d{6}|BECMG|TEMPO|PROB\d{2}))/);
        let worstCategory = 'VFR';
        const winStart = forecastStart.getTime();
        const winEnd = forecastEnd.getTime();
        let baseStart = issueTime.getTime();

        for (const token of tokens) {
            const cleanToken = token.trim();
            if (!cleanToken) continue;
            let chunkStart = baseStart;
            let chunkEnd = 4102444800000;

            if (cleanToken.startsWith('FM')) {
                const d = parseInt(cleanToken.substring(2, 4));
                const h = parseInt(cleanToken.substring(4, 6));
                const m = parseInt(cleanToken.substring(6, 8));
                const fmDate = resolveTafDate(issueTime, d, h);
                fmDate.setUTCMinutes(m);
                chunkStart = fmDate.getTime();
                baseStart = chunkStart;
            } else if (/^(BECMG)/.test(cleanToken)) {
                const timeMatch = cleanToken.match(/(\d{2})(\d{2})\/(\d{2})(\d{2})/);
                if (timeMatch) {
                    const [_, sd, sh, ed, eh] = timeMatch;
                    chunkStart = resolveTafDate(issueTime, parseInt(sd), parseInt(sh)).getTime();
                }
            } else if (/^(TEMPO|PROB)/.test(cleanToken)) {
                const timeMatch = cleanToken.match(/(\d{2})(\d{2})\/(\d{2})(\d{2})/);
                if (timeMatch) {
                    const [_, sd, sh, ed, eh] = timeMatch;
                    chunkStart = resolveTafDate(issueTime, parseInt(sd), parseInt(sh)).getTime();
                    chunkEnd = resolveTafDate(issueTime, parseInt(ed), parseInt(eh)).getTime();
                } else {
                    chunkStart = baseStart;
                }
            }

            if (chunkStart < winEnd && chunkEnd > winStart) {
                const cat = analyzeCondition(cleanToken);
                if (getCategoryPriority(cat) > getCategoryPriority(worstCategory)) {
                    worstCategory = cat;
                }
            }
        }
        return worstCategory;
    }


    function processData(tafDoc, metarDoc, stationMap, homeIcao) {
        const stationDataMap = new Map();
        const getOrCreateStation = (id) => {
            if (!stationDataMap.has(id)) {
                const metadata = stationMap.get(id) || {};
                stationDataMap.set(id, {
                    id: id,
                    name: metadata.name || '',
                    latitude: metadata.latitude || null,
                    longitude: metadata.longitude || null,
                    distanceNM: null,
                    metar: null,
                    taf: null,
                });
            }
            return stationDataMap.get(id);
        };

        metarDoc.querySelectorAll("METAR").forEach(node => {
            const stationId = node.querySelector("station_id")?.textContent;
            if (!stationId) return;
            const station = getOrCreateStation(stationId);
            const { tempF, rh } = calculateTempFAndRH(node);
            const rawText = node.querySelector("raw_text")?.textContent || 'N/A';
            const category = node.querySelector("flight_category")?.textContent || analyzeCondition(rawText);
            const obsTimeText = node.querySelector("observation_time")?.textContent;
            const metarAgeMinutes = calculateAgeInMinutes(obsTimeText);
            station.metar = { rawText, category, tempF, rh, age: metarAgeMinutes, obsTime: obsTimeText };
        });

        tafDoc.querySelectorAll("TAF").forEach(node => {
            const stationId = node.querySelector("station_id")?.textContent;
            if (!stationId) return;
            const station = getOrCreateStation(stationId);
            const rawText = node.querySelector("raw_text")?.textContent || 'N/A';
            const validToText = node.querySelector("valid_time_to")?.textContent;
            const issueTimeText = node.querySelector("issue_time")?.textContent;
            const tafAgeMinutes = calculateAgeInMinutes(issueTimeText);
            let periodHours = null;
            let validToDate = null;
            if (validToText) {
                try {
                    validToDate = new Date(validToText);
                    const now = new Date();
                    const hoursRemaining = (validToDate.getTime() - now.getTime()) / (1000 * 60 * 60);
                    periodHours = Math.max(0, Math.round(hoursRemaining));
                } catch (e) {}
            }
            station.taf = { rawText, periodHours, age: tafAgeMinutes, issueTime: issueTimeText, validTo: validToDate };
        });

        let refLat = null, refLon = null, refName = null;
        if (homeIcao && homeIcao.length >= 3) {
            const homeStationData = getCoordsForICAO(homeIcao, stationMap);
            if (homeStationData && homeStationData.lat !== null) {
                refLat = homeStationData.lat;
                refLon = homeStationData.lon;
                const homeStation = stationDataMap.get(homeIcao.toUpperCase());
                refName = `${homeIcao.toUpperCase()} (${(homeStation && homeStation.name) || 'Unknown'})`;
            }
        }

        if (refLat !== null && refLon !== null) {
            for (let station of stationDataMap.values()) {
                if (station.latitude !== null && station.longitude !== null) {
                    station.distanceNM = haversineDistance(refLat, refLon, station.latitude, station.longitude);
                }
            }
        }

        let stations = Array.from(stationDataMap.values());
        const sortMode = sortModeSelect.value;
        if (sortMode === 'distance' && refLat !== null) {
            stations.sort((a, b) => {
                if (a.distanceNM === null && b.distanceNM === null) return a.id.localeCompare(b.id);
                if (a.distanceNM === null) return 1;
                if (b.distanceNM === null) return -1;
                return a.distanceNM - b.distanceNM;
            });
        } else {
            stations.sort((a, b) => a.id.localeCompare(b.id));
        }
        return { stations, refName, stationDataMap };
    }

    function runRouteAnalysis(stationDataMap, depIcao, destIcao, takeOffTime, landingTime) {
        const dep = depIcao.toUpperCase();
        const dest = destIcao.toUpperCase();
        const depCoords = getCoordsForICAO(dep, cachedStationMap);
        const destCoords = getCoordsForICAO(dest, cachedStationMap);

        if (!depCoords || !destCoords || depCoords.lat === null || destCoords.lat === null) {
            throw new Error("Could not find coordinates for both Departure and Destination airports. Check ICAO codes.");
        }

        const toDate = parseUtcString(takeOffTime);
        const lDate = parseUtcString(landingTime);
        if (!toDate || !lDate) throw new Error("Invalid time format.");

        const ONE_HOUR = 60 * 60 * 1000;
        const takeoffStart = new Date(toDate.getTime() - ONE_HOUR);
        const takeoffEnd = new Date(toDate.getTime() + ONE_HOUR);
        const landingStart = new Date(lDate.getTime() - ONE_HOUR);
        const landingEnd = new Date(lDate.getTime() + ONE_HOUR);
        const now = new Date();

        const depResults = [];
        const destResults = [];

        for (const station of stationDataMap.values()) {
            if (station.latitude === null || station.longitude === null) continue;
            if (!station.taf) continue;
            if (station.taf.validTo && station.taf.validTo < now) continue;

            const distToDep = haversineDistance(depCoords.lat, depCoords.lon, station.latitude, station.longitude);
            const distToDest = haversineDistance(destCoords.lat, destCoords.lon, station.latitude, station.longitude);

            if (distToDep <= MAX_ROUTE_DISTANCE_NM) {
                 const cat = getWorstFlightCategoryFromTAF(station.taf.rawText, takeoffStart, takeoffEnd);
                 depResults.push({ id: station.id, name: station.name, worstCategory: cat, distance: distToDep });
            }
            if (distToDest <= MAX_ROUTE_DISTANCE_NM) {
                 const cat = getWorstFlightCategoryFromTAF(station.taf.rawText, landingStart, landingEnd);
                 destResults.push({ id: station.id, name: station.name, worstCategory: cat, distance: distToDest });
            }
        }

        depResults.sort((a, b) => a.distance - b.distance);
        destResults.sort((a, b) => a.distance - b.distance);

        const depName = stationDataMap.get(dep)?.name || 'Unknown';
        const destName = stationDataMap.get(dest)?.name || 'Unknown';

        return {
            depResults, destResults,
            takeoffStart, takeoffEnd, landingStart, landingEnd,
            depName: dep, destName: dest, depFullName: depName, destFullName: destName
        };
    }

    async function handleGenerateClick() {
        if (typeof pako === 'undefined') {
            showStatus("Error: Required libraries failed to load.", true);
            return;
        }

        try {
            const outputMode = outputModeSelect.value;
            const sortMode = sortModeSelect.value;
            const homeIcao = icaoInput.value.trim().toUpperCase();
            let routeAnalysisResult = null;

            if (sortMode === 'distance' && homeIcao.length < 3) {
                showStatus("Sort Error", true, "To sort by distance, please enter a Home ICAO.");
                return;
            }

            const depIcao = depIcaoInput.value.trim().toUpperCase();
            const destIcao = destIcaoInput.value.trim().toUpperCase();
            const takeOffTime = takeOffTimeInput.value;
            const landingTime = landingTimeInput.value;

            if (routeAnalysisEnabled) {
                if (depIcao.length < 3 || destIcao.length < 3) {
                     showStatus("Route Error", true, "Please enter 3-4 letter ICAO codes for both Departure and Destination.");
                     return;
                }
                if (takeOffTime >= landingTime) {
                     showStatus("Time Error", true, "Landing time must be after Takeoff time.");
                     return;
                }
            }

            generateButton.disabled = true;
            generateButton.textContent = "Fetching Data...";
            generateButton.classList.add('opacity-50', 'cursor-not-allowed');
            showStatus("Fetching METAR, TAF, and Station Database...", false);
            resultsContainerEl.classList.add('hidden');

            const [tafDoc, metarDoc, stationMap] = await Promise.all([
                fetchAndParse(TAF_DATA_URL),
                fetchAndParse(METAR_DATA_URL),
                getStationMap()
            ]);

            showStatus("Processing stations...");
            const processResult = processData(tafDoc, metarDoc, stationMap, homeIcao);
            const stationsData = processResult.stations;
            const stationDataMap = processResult.stationDataMap;
            const usedRef = processResult.refName;

            if (routeAnalysisEnabled) {
                showStatus("Running Alternate Analysis...");
                routeAnalysisResult = runRouteAnalysis(stationDataMap, depIcao, destIcao, takeOffTime, landingTime);
            }

            if (routeAnalysisEnabled) tabRouteAnalysis.classList.remove('hidden');
            else tabRouteAnalysis.classList.add('hidden');

            if (outputMode === 'pdf') {
                if (typeof jsPDF === 'undefined') throw new Error("jsPDF library missing");
                generatePDF(stationsData, usedRef, routeAnalysisResult);
                showSuccess(`PDF generated – ${stationsData.length} stations`);
            } else {
                renderInBrowser(stationsData, usedRef, routeAnalysisResult);
                showSuccess(`Report displayed – ${stationsData.length} stations`);
            }

        } catch (error) {
            console.error(error);
            showStatus(`Error: ${error.message}`, true, "Check console for details.");
        } finally {
            generateButton.disabled = false;
            generateButton.textContent = "Generate Report";
            generateButton.classList.remove('opacity-50', 'cursor-not-allowed');
        }
    }

    function renderRouteAnalysisBrowser(analysisResult) {
        const { depResults, destResults, takeoffStart, takeoffEnd, landingStart, landingEnd, depName, destName } = analysisResult;
        routeAnalysisViewEl.innerHTML = '';
        const tStart = formatTimeHHMM(takeoffStart);
        const tEnd = formatTimeHHMM(takeoffEnd);
        const lStart = formatTimeHHMM(landingStart);
        const lEnd = formatTimeHHMM(landingEnd);

        const headerHtml = `
            <div class="p-4 rounded-xl bg-blue-50 dark:bg-blue-900/30 mb-6 shadow-md text-center">
                <h3 class="text-xl font-bold text-blue-800 dark:text-blue-200">
                    Alternate Analysis: ${depName} to ${destName}
                </h3>
                <p class="text-xs text-gray-500 dark:text-gray-400 mt-2 italic">
                    Stations within ${MAX_ROUTE_DISTANCE_NM} NM. Colors represent worst-case category during the respective windows.
                </p>
            </div>
        `;
        routeAnalysisViewEl.insertAdjacentHTML('beforeend', headerHtml);

        const generateGrid = (items) => {
             if (items.length === 0) return `<div class="text-center p-4 text-gray-500 italic">No alternates found within range.</div>`;
             const tiles = items.map(data => {
                const className = getCategoryTileClassName(data.worstCategory);
                const dotColor = getCategoryColor(data.worstCategory);
                const textColor = (dotColor[0] + dotColor[1] + dotColor[2]) > 300 ? 'text-gray-900' : 'text-white';
                return `
                    <div class="p-3 rounded-lg shadow-md ${className} flex flex-col items-center justify-center space-y-1 transition-transform hover:scale-[1.05] cursor-default"
                         title="${data.id} - ${data.name || 'Unknown'} | Worst Category: ${data.worstCategory} | Distance: ${data.distance.toFixed(0)} NM">
                        <span class="font-bold text-lg font-mono ${textColor}">${data.id}</span>
                        <span class="text-xs ${textColor} opacity-80 text-center truncate w-full">${data.name || 'N/A'}</span>
                        <span class="text-xs font-semibold ${textColor} opacity-90">${data.worstCategory}</span>
                        <span class="text-xs ${textColor} opacity-70">${data.distance.toFixed(0)} NM</span>
                    </div>
                `;
             }).join('');
             return `<div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4">${tiles}</div>`;
        };

        const depSection = `
            <div class="mb-8">
                <div class="flex items-center justify-between mb-3 border-b border-gray-200 dark:border-gray-700 pb-2">
                    <h4 class="text-lg font-bold text-gray-800 dark:text-gray-100">Departure Alternates</h4>
                    <span class="text-xs font-mono bg-gray-200 dark:bg-gray-700 px-2 py-1 rounded text-gray-700 dark:text-gray-200">
                        Window: ${tStart} - ${tEnd}
                    </span>
                </div>
                ${generateGrid(depResults)}
            </div>
        `;
        routeAnalysisViewEl.insertAdjacentHTML('beforeend', depSection);

        const destSection = `
            <div>
                <div class="flex items-center justify-between mb-3 border-b border-gray-200 dark:border-gray-700 pb-2">
                    <h4 class="text-lg font-bold text-gray-800 dark:text-gray-100">Destination Alternates</h4>
                    <span class="text-xs font-mono bg-gray-200 dark:bg-gray-700 px-2 py-1 rounded text-gray-700 dark:text-gray-200">
                        Window: ${lStart} - ${lEnd}
                    </span>
                </div>
                ${generateGrid(destResults)}
            </div>
        `;
        routeAnalysisViewEl.insertAdjacentHTML('beforeend', destSection);
    }

    function renderInBrowser(stationsData, refName, routeAnalysisResult) {
        weatherListEl.innerHTML = '';
        if (refName && sortModeSelect.value === 'distance') {
            const refHeader = document.createElement('div');
            refHeader.className = "bg-blue-50 dark:bg-blue-900/30 p-3 rounded-lg mb-4 text-center text-sm font-bold text-blue-800 dark:text-blue-200";
            refHeader.textContent = `Distances calculated from: ${refName}`;
            weatherListEl.appendChild(refHeader);
        }

        stationsData.forEach(data => {
            const metar = data.metar;
            const taf = data.taf;
            let metarHtml = '<div class="text-gray-500 dark:text-gray-400 italic">No METAR available.</div>';
            let tafHtml = '<div class="text-gray-500 dark:text-gray-400 italic">No TAF available.</div>';
            let headerText = data.id;
            if (data.name) headerText += ` <span class="text-base font-normal text-gray-500 dark:text-gray-400 ml-2">${data.name}</span>`;
            let infoTextParts = [];

            if (metar) {
                const category = metar.category;
                const className = getCategoryClassName(category);
                infoTextParts.push(`${metar.tempF} • ${metar.rh}`);
                infoTextParts.push(`Observed ${formatAge(metar.age)}`);
                if (data.distanceNM !== null) infoTextParts.push(`${data.distanceNM.toFixed(0)} NM`);
                const dotClassToBorderColor = {
                    'vfr-dot': 'border-green-500',
                    'mvfr-dot': 'border-blue-500',
                    'ifr-dot': 'border-red-500',
                    'lifr-dot': 'border-pink-500'
                };
                const borderColorClass = dotClassToBorderColor[className] || 'border-gray-500';
                metarHtml = `<div class="bg-gray-100 dark:bg-gray-700 p-2 rounded-lg border-l-4 ${borderColorClass}">
                                <h4 class="font-bold mb-1 text-sm text-gray-600 dark:text-gray-300">METAR</h4>
                                <p class="font-mono text-xs md:text-sm leading-relaxed">${formatRawText(metar.rawText)}</p>
                             </div>`;
            } else if (data.distanceNM !== null) {
                infoTextParts.push(`Distance: ${data.distanceNM.toFixed(0)} NM`);
            }

            if (taf) {
                let notes = [];
                if (taf.age !== null) notes.push(`Issued ${formatAge(taf.age)}`);
                if (taf.periodHours !== null) notes.push(`Forecast period ends in ${taf.periodHours} hours`);
                let noteHtml = notes.length > 0 ? `<p class="text-xs text-gray-500 dark:text-gray-400 mt-2">${notes.join(' • ')}</p>` : '';
                tafHtml = `<div class="bg-gray-100 dark:bg-gray-700 p-2 rounded-lg">
                            <h4 class="font-bold mb-1 text-sm text-gray-600 dark:text-gray-300">TAF</h4>
                            <div class="space-y-1">${formatRawText(taf.rawText)}</div>
                            ${noteHtml}
                         </div>`;
            }

            const stationEntry = document.createElement('div');
            stationEntry.className = 'border border-gray-200 dark:border-gray-700 rounded-lg p-4 shadow-md bg-white dark:bg-gray-900';
            stationEntry.innerHTML = `
                <div class="flex flex-col sm:flex-row sm:items-baseline justify-between mb-3 border-b pb-2">
                    <h3 class="text-xl font-extrabold text-gray-900 dark:text-gray-100 flex items-baseline flex-wrap">${headerText}</h3>
                    <p class="text-xs text-gray-500 dark:text-gray-400 font-medium">${infoTextParts.join(' • ')}</p>
                </div>
                <div class="space-y-3">${metarHtml}${tafHtml}</div>
            `;
            weatherListEl.appendChild(stationEntry);
        });

        if (routeAnalysisResult) {
            renderRouteAnalysisBrowser(routeAnalysisResult);
            switchTab('standard');
        } else {
            tabRouteAnalysis.classList.add('hidden');
            switchTab('standard');
        }
        resultsContainerEl.classList.remove('hidden');
    }

    function formatRawText(rawText) {
        const formatted = rawText.replace(/(FM\d{6}|BECMG|PROB\d{2} TEMPO|PROB\d{2}|TEMPO)/g, "\n<span class='font-bold text-white'>$1</span>");
        const lines = formatted.split('\n').map(l => l.trim()).filter(l => l);
        let html = '';
        for (const line of lines) {
            const category = analyzeCondition(line.replace(/<[^>]*>?/gm, ''));
            const className = getCategoryClassName(category);
            const highlightedLine = line.split(' ').map(word => {
                return isPrecipOrTS(word) ? `<span class="font-bold">${word}</span>` : word;
            }).join(' ');
            const bgClass = {
                'vfr-dot': 'bg-green-600',
                'mvfr-dot': 'bg-blue-600',
                'ifr-dot': 'bg-red-600',
                'lifr-dot': 'bg-pink-600'
            }[className] || 'bg-gray-500';
            html += `<div class="font-mono text-xs md:text-sm leading-relaxed p-1 rounded-md text-white ${bgClass}">${highlightedLine}</div>`;
        }
        return html;
    }

    function isPrecipOrTS(word) {
        const clean = word.replace(/[,.;]+$/, '').toUpperCase();
        const regex = /^([-+]|VC)?(RA|SN|DZ|SG|IC|PL|GR|GS|UP|TS|SH|FZ|BR|FG|HZ){1,4}$/i;
        return regex.test(clean);
    }

    // --- PDF GENERATOR ---

    function drawStyledText(doc, lineText, x, y, baseColor) {
        const words = lineText.split(' ');
        let currentX = x;
        doc.setTextColor(...baseColor);
        doc.setFont("courier", "normal");
        doc.setFontSize(9);
        const spaceWidth = doc.getTextWidth(" ");
        for (let word of words) {
            const shouldBold = isPrecipOrTS(word);
            doc.setFont("courier", shouldBold ? "bold" : "normal");
            doc.text(word, currentX, y);
            currentX += doc.getTextWidth(word) + spaceWidth;
        }
    }

    function drawRouteAnalysisPDFPage(doc, analysisResult) {
        const { depResults, destResults, takeoffStart, takeoffEnd, landingStart, landingEnd, depName, destName, depFullName, destFullName } = analysisResult;
        let cursorY = PAGE_MARGIN;
        const tStart = formatTimeHHMM(takeoffStart);
        const tEnd = formatTimeHHMM(takeoffEnd);
        const lStart = formatTimeHHMM(landingStart);
        const lEnd = formatTimeHHMM(landingEnd);

        doc.setFont("helvetica", "bold");
        doc.setFontSize(18);
        doc.setTextColor(30, 30, 30);
        doc.text("Alternate Weather Analysis", PAGE_WIDTH / 2, cursorY, { align: "center" });
        cursorY += 10;
        doc.setFontSize(12);
        doc.setTextColor(50, 50, 50);
        doc.text(`Flight: ${depName} (${depFullName}) to ${destName} (${destFullName})`, PAGE_WIDTH / 2, cursorY, { align: "center" });
        cursorY += 10;

        const drawGridSection = (title, windowStr, items) => {
             if (cursorY + 20 > PAGE_HEIGHT - PAGE_MARGIN) {
                 doc.addPage();
                 cursorY = PAGE_MARGIN;
             }
             doc.setFont("helvetica", "bold");
             doc.setFontSize(14);
             doc.setTextColor(30, 30, 30);
             doc.text(title, PAGE_MARGIN, cursorY);
             doc.setFont("courier", "normal");
             doc.setFontSize(10);
             doc.setTextColor(80, 80, 80);
             doc.text(windowStr, PAGE_WIDTH - PAGE_MARGIN, cursorY, { align: "right" });
             cursorY += 8;
             doc.setLineWidth(0.2);
             doc.setDrawColor(200, 200, 200);

             let startTileX = PAGE_MARGIN;
             const tileWidth = 30;
             const tileHeight = 15;
             const tileMargin = 5;
             const maxTilesPerRow = Math.floor(USABLE_WIDTH / (tileWidth + tileMargin));
             let col = 0;
             let row = 0;

             if (items.length === 0) {
                 doc.setFont("helvetica", "italic");
                 doc.setFontSize(10);
                 doc.text("No alternates found within range.", PAGE_MARGIN, cursorY);
                 cursorY += 15;
                 return;
             }

             for (const data of items) {
                const color = getCategoryColor(data.worstCategory);
                doc.setFillColor(...color);
                let x = startTileX + col * (tileWidth + tileMargin);
                let y = cursorY + row * (tileHeight + tileMargin);
                if (y + tileHeight > PAGE_HEIGHT - PAGE_MARGIN) {
                    doc.addPage();
                    cursorY = PAGE_MARGIN;
                    row = 0; col = 0;
                    doc.setLineWidth(0.2);
                    doc.setDrawColor(200, 200, 200);
                    doc.setFillColor(...color);
                    x = startTileX + col * (tileWidth + tileMargin);
                    y = cursorY + row * (tileHeight + tileMargin);
                }
                doc.rect(x, y, tileWidth, tileHeight, 'FD');
                const avgColor = (color[0] + color[1] + color[2]) / 3;
                doc.setTextColor(avgColor > 128 ? 0 : 255, avgColor > 128 ? 0 : 255, avgColor > 128 ? 0 : 255);
                doc.setFont("helvetica", "bold");
                doc.setFontSize(9);
                doc.text(data.id, x + tileWidth / 2, y + 5, { align: 'center' });
                doc.setFont("helvetica", "normal");
                doc.setFontSize(6);
                doc.text(`${data.worstCategory} / ${data.distance.toFixed(0)} NM`, x + tileWidth / 2, y + 10, { align: 'center' });
                col++;
                if (col >= maxTilesPerRow) { col = 0; row++; }
             }
             cursorY += (row + 1) * (tileHeight + tileMargin) + 5;
        };

        drawGridSection("Departure Alternates", `Window: ${tStart} - ${tEnd}`, depResults);
        drawGridSection("Destination Alternates", `Window: ${lStart} - ${lEnd}`, destResults);
        return cursorY;
    }

    function drawPdfLegend(doc, cursorY) {
        doc.setFont("helvetica", "bold");
        doc.setFontSize(10);
        doc.text("METAR Flight Categories", PAGE_WIDTH / 2, cursorY, { align: "center" });
        cursorY += 6;
        const legendItems = [
            { label: "VFR", color: COLORS.VFR },
            { label: "MVFR", color: COLORS.MVFR },
            { label: "IFR", color: COLORS.IFR },
            { label: "LIFR", color: COLORS.LIFR },
            { label: "NODATA", color: COLORS.NODATA }
        ];
        const itemWidth = 30;
        const totalLegendWidth = legendItems.length * itemWidth;
        const startX = (PAGE_WIDTH - totalLegendWidth) / 2;
        const boxSize = 4;
        const padding = 4;
        for (let i = 0; i < legendItems.length; i++) {
            const x = startX + i * itemWidth;
            const item = legendItems[i];
            doc.setFillColor(...item.color);
            doc.rect(x, cursorY - 3, boxSize, boxSize, 'F');
            doc.setFont("helvetica", "normal");
            doc.setFontSize(8);
            doc.setTextColor(30, 30, 30);
            doc.text(item.label, x + boxSize + padding, cursorY);
        }
        return cursorY + 6;
    }

    function generatePDF(stationsData, refName, routeAnalysisResult) {
        const doc = new jsPDF({ orientation: "portrait", unit: "mm", format: "a4" });
        let cursorY = PAGE_MARGIN;
        if (routeAnalysisResult) {
            drawRouteAnalysisPDFPage(doc, routeAnalysisResult);
            doc.addPage();
        }
        cursorY = PAGE_MARGIN;
        const now = new Date();
        const utc = now.toISOString().replace('T', ' ').substring(0, 19);
        doc.setFont("helvetica", "bold");
        doc.setFontSize(22);
        doc.setTextColor(30, 30, 30);
        doc.text("Aviation Weather Report", PAGE_WIDTH / 2, cursorY + 5, { align: "center" });
        doc.setFontSize(14);
        doc.text("METAR & TAF Details", PAGE_WIDTH / 2, cursorY + 12, { align: "center" });
        cursorY += 20;
        doc.setFontSize(10);
        doc.setFont("helvetica", "normal");
        doc.text(`Generated (UTC): ${utc} Z`, PAGE_WIDTH / 2, cursorY + 5, { align: "center" });
        doc.text(`Total Stations: ${stationsData.length}`, PAGE_WIDTH / 2, cursorY + 10, { align: "center" });
        cursorY += 15;
        const sortMode = sortModeSelect.value;
        let sortDetail = "Sorted Alphabetically by Station ID";
        if (sortMode === 'distance' && refName) sortDetail = `Sorted by Distance from ${refName}`;
        doc.text(sortDetail, PAGE_WIDTH / 2, cursorY, { align: "center" });
        cursorY += 10;
        cursorY = drawPdfLegend(doc, cursorY);
        doc.setDrawColor(220, 220, 220);
        doc.line(PAGE_MARGIN, cursorY, PAGE_WIDTH - PAGE_MARGIN, cursorY);
        cursorY += 5;

        for (const data of stationsData) {
            const stationId = data.id;
            const headerTitle = data.name ? `${stationId} - ${data.name}` : stationId;
            let metarLines = [];
            let metarColor = COLORS.VFR;
            let infoText = "";
            let infoTextParts = [];
            if (data.metar) {
                doc.setFont("courier", "normal");
                doc.setFontSize(9);
                metarLines = doc.splitTextToSize(data.metar.rawText, USABLE_WIDTH - 35);
                metarColor = getCategoryColor(data.metar.category);
                infoTextParts.push(`${data.metar.tempF} • ${data.metar.rh}`);
                infoTextParts.push(`Observed ${formatAge(data.metar.age)}`);
                if (data.distanceNM !== null) infoTextParts.push(`${data.distanceNM.toFixed(0)} NM`);
                infoText = infoTextParts.join(' • ');
            } else if (data.distanceNM !== null) {
                infoText = `Distance: ${data.distanceNM.toFixed(0)} NM (No METAR)`;
            }

            let tafBlocks = [];
            let tafPeriodNote = '', tafIssueNote = '';
            if (data.taf) {
                const formatted = data.taf.rawText.replace(/(FM\d{6}|BECMG|PROB\d{2} TEMPO|PROB\d{2}|TEMPO)/g, "\n$1");
                const rawBlocks = formatted.split('\n').map(l => l.trim()).filter(l => l);
                doc.setFont("courier", "normal");
                doc.setFontSize(9);
                tafBlocks = rawBlocks.map(block => ({
                    lines: doc.splitTextToSize(block, USABLE_WIDTH - 35),
                    raw: block
                }));
                if (data.taf.periodHours !== null) tafPeriodNote = `Forecast period ends in ${data.taf.periodHours} hours`;
                if (data.taf.age !== null) tafIssueNote = `Issued ${formatAge(data.taf.age)}`;
            }

            doc.setFont("helvetica", "bold");
            doc.setFontSize(12);
            const headerLines = doc.splitTextToSize(headerTitle, USABLE_WIDTH);
            let heightNeeded = 3 + (headerLines.length * 6);
            if (infoText) heightNeeded += 6;
            if (metarLines.length > 0) heightNeeded += metarLines.length * LINE_SPACING + 3;
            if (tafBlocks.length > 0) {
                for (const block of tafBlocks) heightNeeded += block.lines.length * LINE_SPACING;
                heightNeeded += 5;
            }
            if (tafPeriodNote || tafIssueNote) heightNeeded += LINE_SPACING;

            if (cursorY + heightNeeded > PAGE_HEIGHT - PAGE_MARGIN - 10) {
                doc.addPage();
                cursorY = PAGE_MARGIN;
            }

            doc.setFont("helvetica", "bold");
            doc.setFontSize(12);
            doc.setTextColor(0, 0, 0);
            headerLines.forEach(line => {
                doc.text(line, PAGE_MARGIN, cursorY);
                cursorY += 5;
            });

            if (infoText) {
                doc.setFont("helvetica", "normal");
                doc.setFontSize(10);
                doc.setTextColor(80, 80, 80);
                doc.text(infoText, PAGE_MARGIN, cursorY);
                cursorY += 6;
            } else { cursorY += 2; }

            if (data.metar) {
                doc.setFont("helvetica", "bold");
                doc.setFontSize(9);
                doc.setTextColor(60, 60, 60);
                doc.text("METAR:", PAGE_MARGIN + 2, cursorY);
                for (const line of metarLines) {
                    drawStyledText(doc, line, PAGE_MARGIN + 18, cursorY, metarColor);
                    cursorY += LINE_SPACING;
                }
                cursorY += 2;
            }

            if (data.taf) {
                doc.setFont("helvetica", "bold");
                doc.setFontSize(9);
                doc.setTextColor(60, 60, 60);
                doc.text("TAF:", PAGE_MARGIN + 2, cursorY);
                for (const block of tafBlocks) {
                    const blockColor = getCategoryColor(analyzeCondition(block.raw));
                    for (const line of block.lines) {
                        drawStyledText(doc, line, PAGE_MARGIN + 18, cursorY, blockColor);
                        cursorY += LINE_SPACING;
                    }
                }
                cursorY += 2;
                let tafNotes = [];
                if (tafIssueNote) tafNotes.push(tafIssueNote);
                if (tafPeriodNote) tafNotes.push(tafPeriodNote);
                if (tafNotes.length > 0) {
                    doc.setFont("helvetica", "normal");
                    doc.setFontSize(8);
                    doc.setTextColor(100, 100, 100);
                    doc.text(tafNotes.join(' • '), PAGE_MARGIN + 18, cursorY);
                    cursorY += LINE_SPACING;
                }
            }
            doc.setDrawColor(220, 220, 220);
            doc.setLineWidth(0.1);
            doc.line(PAGE_MARGIN, cursorY, PAGE_WIDTH - PAGE_MARGIN, cursorY);
            cursorY += 6;
        }

        try {
            const pdfDataUri = doc.output('datauristring');
            const base64Data = pdfDataUri.substring(pdfDataUri.indexOf(',') + 1);
            if (window.Android && typeof window.Android.savePdf === 'function') {
                window.Android.savePdf(base64Data, "weather-report-combined.pdf");
            } else {
                doc.save("weather-report-combined.pdf");
            }
        } catch (e) {
            console.error('PDF export failed:', e);
            try { doc.save("weather-report-combined.pdf"); } catch (ee) { }
        }
    }
</script>
</body>
</html>